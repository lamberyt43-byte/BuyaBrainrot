<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Buy A Brainrot — Neon Prototype</title>

  <style>
    :root{
    --bg-1:#05060a; --bg-2:#081322;
    --panel:#0e1620; --muted:#9fb0bf;
    --neon-green:#00ff88; --neon-green-2:#00cc77;
    --red-1:#ff3b30; --accent:#20c997;
    --rar-common:#32d74b; --rar-epic:#9b59ff; --rar-legend:#ffd166; --rar-secret:#ffffff; --rar-super:#ff4d6d;
    --card-w:220px;
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));font-family:Inter,Segoe UI,Roboto,Arial;color:#e6f2f8}
  .app{max-width:1200px;margin:18px auto;padding:18px;position:relative}
  header{display:flex;align-items:center;gap:14px}
  h1{margin:0;font-size:22px;letter-spacing:0.6px}
  .hud{margin-left:auto;display:flex;gap:14px;align-items:center;color:var(--muted);font-weight:700}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}

  /* CONVEYOR */
  .conveyorWrap{margin-top:14px;position:relative;height:150px;overflow:hidden;border-radius:14px}
  .conveyor {
    position:relative;height:100%;border-radius:12px;
    background:
      linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)),
      linear-gradient(90deg,#7b0810,#cc0f13);
    box-shadow: inset 0 6px 30px rgba(0,0,0,0.6), 0 8px 40px rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.04);
    overflow:hidden;
  }
  /* subtle moving stripes */
  .conveyor::before{
    content:""; position:absolute; inset:0; background-image: linear-gradient(90deg, rgba(255,255,255,0.02) 0 10px, transparent 10px 40px);
    opacity:0.16; mix-blend-mode:overlay; animation: stripes 6s linear infinite;
  }
  @keyframes stripes { from { background-position:0 0 } to { background-position:160px 0 } }

  .lane { position:absolute; inset:0; pointer-events:none } /* cards are placed absolutely */
  /* CARD */
  .card {
    position:absolute; top:50%; transform:translateY(-50%);
    width:var(--card-w); padding:12px 10px; border-radius:12px;
    background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    pointer-events:auto; cursor:pointer;
    transition: transform .12s ease, box-shadow .12s ease;
    text-align:center;
  }
  .card:hover{ transform: translateY(-50%) scale(1.035); box-shadow:0 12px 30px rgba(0,0,0,0.7) }

  .c-name{font-weight:800;font-size:15px;margin-bottom:6px}
  .c-rarity{font-weight:700;margin-bottom:6px}
  .c-income{color:var(--neon-green);font-weight:700;margin-bottom:6px}
  .c-price{color:var(--rar-legend);font-weight:900}

  /* rarity glows */
  .r-common{border:1px solid rgba(50,215,75,0.12); box-shadow:0 6px 18px rgba(50,215,75,0.06)}
  .r-epic{border:1px solid rgba(155,89,255,0.12); box-shadow:0 6px 18px rgba(155,89,255,0.05)}
  .r-legend{border:1px solid rgba(255,209,102,0.12); box-shadow:0 8px 28px rgba(255,209,102,0.06)}
  .r-secret{border:1px solid rgba(255,255,255,0.12); box-shadow:0 10px 36px rgba(255,255,255,0.06)}
  .r-super{border:1px solid rgba(255,77,109,0.14); box-shadow:0 10px 36px rgba(255,77,109,0.06)}

  /* BASE */
  .baseWrap{margin-top:18px}
  .baseHeader{display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:8px}
  .baseTitle{font-size:18px;font-weight:800;color:#e6f2f8}
  .baseGrid{display:grid;grid-template-columns:repeat(10,1fr);gap:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:14px;border-radius:12px}
  .slot{
    background:linear-gradient(180deg,#0f6f1f,#0c5d18); border-radius:10px; min-height:86px; padding:8px;
    display:flex;flex-direction:column;align-items:center;justify-content:center;color:#022; font-weight:800; font-size:13px;
    box-shadow: inset 0 4px 10px rgba(0,0,0,0.3);
    cursor:pointer;
  }
  .slot.empty{background:linear-gradient(180deg,#111,#0e0e0e); color:var(--muted); font-weight:700}
  .slot .s-name{color:#fff;font-weight:900}
  .slot .s-meta{font-size:12px;color:rgba(255,255,255,0.9);font-weight:700}

  /* HUD money */
  #moneyHUD{
    position:fixed; left:50%; bottom:22px; transform:translateX(-50%); z-index:40;
    background:linear-gradient(90deg, rgba(0,0,0,0.45), rgba(0,0,0,0.18));
    padding:10px 16px;border-radius:999px; font-weight:900; color:var(--neon-green);
    box-shadow:0 8px 40px rgba(0,180,120,0.08), 0 0 18px rgba(0,255,160,0.06); border:1px solid rgba(255,255,255,0.03);
    text-shadow:0 0 8px rgba(0,255,180,0.06);
    transition:transform .18s ease;
  }

  /* message */
  #msg{position:fixed;left:50%;top:30px;transform:translateX(-50%);padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.6);color:#fff;font-weight:800;opacity:0;transition:all .25s}

  /* help note */
  .note{position:fixed;right:18px;top:80px;color:rgba(255,255,255,0.14);font-size:13px;text-align:right}

  @media(max-width:980px){
    .baseGrid{grid-template-columns:repeat(5,1fr)}
    :root{--card-w:180px}
  }
  </style>

  
</head>
<body>
  <div class="app">
    <header>
      <h1>Buy A Brainrot</h1>
      <div class="hud"><div id="slotsHUD">Slots: 0/10</div><div style="opacity:.8">Beta V0.12</div></div>
    </header>

    <div class="panel conveyorWrap">
      <div class="conveyor">
        <div class="lane" id="lane" aria-label="conveyor-lane"></div>
      </div>
    </div>

    <div class="panel baseWrap">
      <div class="baseHeader"><div class="baseTitle">Your Base</div></div>
      <div class="baseGrid" id="baseGrid" aria-label="base"></div>
      <div style="margin-top:8px;text-align:center;color:var(--muted);font-size:13px">Click slot: collect · Double click slot: sell (50%)</div>
    </div>
  </div>

  <div id="moneyHUD">$ 1,000</div>
  <div id="msg"></div>
  <div class="note">Click a Brainrot to buy • Rare chances are low</div>

  <script>
    /* ----------------- DATA ----------------- */
/* user's brainrots (translated & normalized) */
const BRAINROTS = [
  {id:'la', name:'La meilo penailo', rarity:'super', income:29_000_000, price:750_000_000},
  {id:'n52', name:'52', rarity:'super', income:510_000_000, price:15_000_000_000},
  {id:'bindin', name:'Bin din grin gargur', rarity:'super', income:50_000_000, price:1_000_000_000},

  {id:'labubu', name:'Labubu Habubu', rarity:'legend', income:2000, price:30_000},
  {id:'bruz', name:'bruzbruzbruzi', rarity:'legend', income:5_000, price:500_000},
  {id:'wiiii', name:'Wiiiiiiiiibu', rarity:'legend', income:5_000, price:2_000_000},
  {id:'boom', name:'Boom boom boom gargur', rarity:'legend', income:1_500, price:450_000},
  {id:'grun', name:'Grun orgun grun kombinasion', rarity:'legend', income:2_000, price:1_000_000},
  {id:'dooog', name:'DOOOOG DOOOOG DOOOOG', rarity:'legend', income:1_000, price:500_000},

  {id:'ham', name:'HamHam Lodkahabam', rarity:'secret', income:15_000_000, price:600_000_000},
  {id:'gragra', name:'Gragragraku', rarity:'secret', income:30_000_000, price:3_000_000_000},
  {id:'dum', name:'Dum di di di dum', rarity:'secret', income:30_000_000, price:1_000_000_000},
  {id:'primb', name:'Prim brum mega gargur', rarity:'secret', income:2_000_000, price:90_000_000},
  {id:'kit', name:'Kitini futbolini', rarity:'secret', income:1_000_000, price:47_000_000},

  {id:'abibas', name:'Abibas', rarity:'common', income:3, price:40},
  {id:'graz', name:'Grazogera', rarity:'common', income:10, price:400},
  {id:'pah', name:'Pah pah pah gargur', rarity:'common', income:2, price:25},

  {id:'peppi', name:'Peppi sola', rarity:'epic', income:480, price:4_500},
  {id:'vrum', name:'Vrum Vrum barabum', rarity:'epic', income:150, price:10_000}
];
/* spawn weight by rarity (lower = rarer) */
const RARITY_WEIGHTS = { common:80, epic:10, legend:19, secret:1, super:1 };

/* ----------------- STATE ----------------- */
let balance = 1000;
const MAX_SLOTS = 10;
let base = []; // entries: {uid, meta, stored, lastTick}
const LANE_COUNT = 5;
const LANE_SPACING = 280; // px between cards
const LANE_SPEED = 40; // px per second (moderate speed)
let cards = []; // {el, pos, meta}

/* DOM refs */
const laneEl = document.getElementById('lane');
const baseGrid = document.getElementById('baseGrid');
const moneyHUD = document.getElementById('moneyHUD');
const msgEl = document.getElementById('msg');
const slotsHUD = document.getElementById('slotsHUD');

/* build weighted pool */
const pool = [];
for(const b of BRAINROTS){
  const w = RARITY_WEIGHTS[b.rarity] || 5;
  for(let i=0;i<w;i++) pool.push(b.id);
}
function pickRandom() {
  const id = pool[Math.floor(Math.random()*pool.length)];
  return BRAINROTS.find(x=>x.id===id);
}

/* AUDIO (tiny synth) */
const ACTX = new (window.AudioContext||window.webkitAudioContext)();
function playTone(freq, dur=0.08, type='sine', vol=0.06){
  const o = ACTX.createOscillator(), g = ACTX.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol; o.connect(g); g.connect(ACTX.destination);
  o.start(); o.stop(ACTX.currentTime + dur);
}
function sBuy(){ playTone(880,0.06); setTimeout(()=>playTone(1320,0.05),70) }
function sErr(){ playTone(120,0.12,'square',0.12) }
function sCollect(){ playTone(660,0.06); setTimeout(()=>playTone(880,0.04),60) }
function sSell(){ playTone(520,0.06,'triangle'); setTimeout(()=>playTone(320,0.06),60) }

/* UI helpers */
function fmt(n){
  if(n>=1e12) return (n/1e12).toFixed(2)+'T';
  if(n>=1e9) return (n/1e9).toFixed(2)+'B';
  if(n>=1e6) return (n/1e6).toFixed(2)+'M';
  if(n>=1000) return (n/1000).toFixed(1)+'k';
  return Math.floor(n).toString();
}
function showMsg(text, bad=false){
  msgEl.textContent = text;
  msgEl.style.background = bad ? 'rgba(170,30,30,0.75)' : 'rgba(2,80,30,0.7)';
  msgEl.style.opacity = '1';
  clearTimeout(msgEl._t);
  msgEl._t = setTimeout(()=> msgEl.style.opacity = '0', 1400);
}
function updateHUD(){
  moneyHUD.textContent = `$ ${fmt(balance)}`;
  moneyHUD.style.transform = 'translateX(-50%) scale(1.06)';
  setTimeout(()=> moneyHUD.style.transform = 'translateX(-50%) scale(1)', 140);
  slotsHUD.textContent = `Slots: ${base.length}/${MAX_SLOTS}`;
}

/* ----------------- LANE logic: even formation ----------------- */
/* We maintain LANE_COUNT cards spaced by LANE_SPACING, with identical speed.
   Positions are px from left edge. When card moves off right, wrap to left-most - spacing.
*/
function createCard(meta, initialX){
  const el = document.createElement('div');
  el.className = `card r-${meta.rarity}`;
  el.style.width = getComputedStyle(document.documentElement).getPropertyValue('--card-w') || '220px';
  el.innerHTML = `<div class="c-name">${meta.name}</div>
                  <div class="c-rarity">${meta.rarity.toUpperCase()}</div>
                  <div class="c-income">+${fmt(meta.income)}/s</div>
                  <div class="c-price">Price: $${fmt(meta.price)}</div>`;
  // click to buy
  el.addEventListener('click', ()=> buyFromLane(meta, el));
  laneEl.appendChild(el);
  const card = { el, pos: initialX, meta };
  el.style.left = initialX + 'px';
  cards.push(card);
  return card;
}
function initLane(){
  // clear existing
  for(const c of cards){ c.el.remove(); }
  cards = [];
  const startLeft = - (LANE_SPACING * (LANE_COUNT - 1));
  for(let i=0;i<LANE_COUNT;i++){
    const meta = pickRandom();
    const x = startLeft + i * LANE_SPACING;
    createCard(meta, x);
  }
}

/* move cards each frame */
let lastT = performance.now();
function tick(now){
  const dt = (now - lastT)/1000; lastT = now;
  const width = laneEl.clientWidth || window.innerWidth;
  for(let i=0;i<cards.length;i++){
    const c = cards[i];
    c.pos += LANE_SPEED * dt;
    // update style
    c.el.style.left = c.pos + 'px';
  }
  // wrap if rightmost exceeded
  for(let i=0;i<cards.length;i++){
    const c = cards[i];
    const elW = c.el.offsetWidth || 220;
    if(c.pos > width + 40){
      // find leftmost
      const leftmost = Math.min(...cards.map(x=>x.pos));
      c.pos = leftmost - LANE_SPACING;
      // replace meta with new random (so chain keeps variety)
      const newMeta = pickRandom();
      c.meta = newMeta;
      c.el.innerHTML = `<div class="c-name">${newMeta.name}</div>
                        <div class="c-rarity">${newMeta.rarity.toUpperCase()}</div>
                        <div class="c-income">+${fmt(newMeta.income)}/s</div>
                        <div class="c-price">Price: $${fmt(newMeta.price)}</div>`;
      // rebind click handler cleanly
      c.el.onclick = ()=> buyFromLane(newMeta, c.el);
    }
  }
  requestAnimationFrame(tick);
}

/* ----------------- BUY FROM LANE ----------------- */
function buyFromLane(meta, el){
  if(balance < meta.price){ showMsg('Not enough money!', true); sErr(); return; }
  if(base.length >= MAX_SLOTS){ showMsg('Base is full!', true); sErr(); return; }
  // purchase
  balance -= meta.price; sBuy(); showMsg(`You bought: ${meta.name}`);
  addToBase(meta);
  updateHUD();
  // remove the visual element that was clicked: find card and respawn it at leftmost - spacing
  const cIndex = cards.findIndex(c=>c.el===el);
  if(cIndex!==-1){
    const c = cards[cIndex];
    const leftmost = Math.min(...cards.map(x=>x.pos));
    c.pos = leftmost - LANE_SPACING;
    // new meta for visual
    const newMeta = pickRandom();
    c.meta = newMeta;
    c.el.innerHTML = `<div class="c-name">${newMeta.name}</div>
                      <div class="c-rarity">${newMeta.rarity.toUpperCase()}</div>
                      <div class="c-income">+${fmt(newMeta.income)}/s</div>
                      <div class="c-price">Price: $${fmt(newMeta.price)}</div>`;
    c.el.onclick = ()=> buyFromLane(newMeta, c.el);
  }
}

/* ----------------- BASE MANAGEMENT ----------------- */
function addToBase(meta){
  const entry = { uid: meta.id + '_' + Date.now() + '_' + Math.random().toString(36).slice(2),
                  meta: JSON.parse(JSON.stringify(meta)), stored:0, lastTick: Date.now() };
  base.push(entry);
  renderBase();
}
function renderBase(){
  baseGrid.innerHTML = '';
  for(let i=0;i<MAX_SLOTS;i++){
    const slot = document.createElement('div');
    const ent = base[i];
    if(ent){
      slot.className = 'slot';
      slot.innerHTML = `<div class="s-name">${ent.meta.name}</div>
                        <div class="s-meta">${ent.meta.rarity.toUpperCase()}</div>
                        <div class="s-meta">Income: ${fmt(ent.meta.income)}/s</div>
                        <div class="s-meta">Stored: $${fmt(Math.floor(ent.stored))}</div>`;
      // click vs dblclick
      let clickTimer = null;
      slot.addEventListener('click', ()=>{
        if(clickTimer==null){
          clickTimer = setTimeout(()=>{
            clickTimer = null;
            collect(ent.uid);
          }, 220);
        }
      });
      slot.addEventListener('dblclick', ()=>{
        if(clickTimer){ clearTimeout(clickTimer); clickTimer = null; }
        sell(ent.uid);
      });
    } else {
      slot.className = 'slot empty';
      slot.textContent = 'Empty';
    }
    baseGrid.appendChild(slot);
  }
  updateHUD();
}

/* collect stored */
function collect(uid){
  const idx = base.findIndex(x=>x.uid===uid); if(idx===-1) return;
  tickEntry(base[idx]);
  const gained = Math.floor(base[idx].stored);
  if(gained<=0){ showMsg('Nothing to collect'); return; }
  base[idx].stored = 0; base[idx].lastTick = Date.now();
  balance += gained; sCollect(); showMsg(`Collected $${fmt(gained)}`); renderBase(); updateHUD();
}

/* sell */
function sell(uid){
  const idx = base.findIndex(x=>x.uid===uid); if(idx===-1) return;
  const ent = base[idx];
  const amount = Math.floor(ent.meta.price * 0.5);
  base.splice(idx,1);
  balance += amount; sSell(); showMsg(`Sold ${ent.meta.name} for $${fmt(amount)}`); renderBase(); updateHUD();
}

/* ticking stored incomes */
function tickEntry(ent){
  const now = Date.now();
  const dt = (now - ent.lastTick)/1000;
  if(dt<=0) return;
  ent.stored += ent.meta.income * dt;
  ent.lastTick = now;
}

/* passive tick each second */
setInterval(()=>{
  for(const e of base) tickEntry(e);
  // re-render base to update stored display (light)
  renderBase();
},1000);

/* init everything */
initLane();
lastT = performance.now();
requestAnimationFrame(tick);
renderBase();
updateHUD();

/* resume audio on first user gesture */
document.addEventListener('click', function resume(){ if(ACTX.state==='suspended') ACTX.resume(); document.removeEventListener('click', resume); });

/* responsive: adjust spacing if screen too small */
window.addEventListener('resize', ()=>{
  const w = window.innerWidth;
  if(w < 900) {
    // tighten spacing
    // Note: LANE_SPACING is const; keep as visual tweak only by shifting existing positions slightly
  }
});
  </script>
</body>
</html>
